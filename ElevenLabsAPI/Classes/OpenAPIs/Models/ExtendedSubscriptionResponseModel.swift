//
// ExtendedSubscriptionResponseModel.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ExtendedSubscriptionResponseModel: Codable, JSONEncodable, Hashable {

    public var tier: String
    public var characterCount: Int
    public var characterLimit: Int
    public var canExtendCharacterLimit: Bool
    public var allowedToExtendCharacterLimit: Bool
    public var nextCharacterCountResetUnix: Int
    public var voiceLimit: Int
    public var canExtendVoiceLimit: Bool
    public var canUseInstantVoiceCloning: Bool
    public var nextInvoice: InvoiceResponseModel

    public init(tier: String, characterCount: Int, characterLimit: Int, canExtendCharacterLimit: Bool, allowedToExtendCharacterLimit: Bool, nextCharacterCountResetUnix: Int, voiceLimit: Int, canExtendVoiceLimit: Bool, canUseInstantVoiceCloning: Bool, nextInvoice: InvoiceResponseModel) {
        self.tier = tier
        self.characterCount = characterCount
        self.characterLimit = characterLimit
        self.canExtendCharacterLimit = canExtendCharacterLimit
        self.allowedToExtendCharacterLimit = allowedToExtendCharacterLimit
        self.nextCharacterCountResetUnix = nextCharacterCountResetUnix
        self.voiceLimit = voiceLimit
        self.canExtendVoiceLimit = canExtendVoiceLimit
        self.canUseInstantVoiceCloning = canUseInstantVoiceCloning
        self.nextInvoice = nextInvoice
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case tier
        case characterCount = "character_count"
        case characterLimit = "character_limit"
        case canExtendCharacterLimit = "can_extend_character_limit"
        case allowedToExtendCharacterLimit = "allowed_to_extend_character_limit"
        case nextCharacterCountResetUnix = "next_character_count_reset_unix"
        case voiceLimit = "voice_limit"
        case canExtendVoiceLimit = "can_extend_voice_limit"
        case canUseInstantVoiceCloning = "can_use_instant_voice_cloning"
        case nextInvoice = "next_invoice"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(tier, forKey: .tier)
        try container.encode(characterCount, forKey: .characterCount)
        try container.encode(characterLimit, forKey: .characterLimit)
        try container.encode(canExtendCharacterLimit, forKey: .canExtendCharacterLimit)
        try container.encode(allowedToExtendCharacterLimit, forKey: .allowedToExtendCharacterLimit)
        try container.encode(nextCharacterCountResetUnix, forKey: .nextCharacterCountResetUnix)
        try container.encode(voiceLimit, forKey: .voiceLimit)
        try container.encode(canExtendVoiceLimit, forKey: .canExtendVoiceLimit)
        try container.encode(canUseInstantVoiceCloning, forKey: .canUseInstantVoiceCloning)
        try container.encode(nextInvoice, forKey: .nextInvoice)
    }
}

